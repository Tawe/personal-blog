import type { AuthMethod, Diagram, FlowVariantId, LaneId, Step } from "../types"

// Add a new method by creating a Diagram (lanes/edges/flows/overlays) and attaching it to an AuthMethod.
// Steps should reference edge IDs in `activeEdges` so FlowCanvas can highlight movement per step.

const defaultLanes: LaneId[] = ["user", "client", "auth", "api", "store"]

const emptyFlows: Record<FlowVariantId, Step[]> = {
  happy: [],
  refresh: [],
  logout: [],
  attack: [],
}

function stubDiagram(name: string): Diagram {
  return {
    lanes: defaultLanes,
    edges: [
      { id: `${name}-e1`, fromLane: "client", toLane: "auth", label: "auth call", style: "solid", semantics: "code" },
      { id: `${name}-e2`, fromLane: "client", toLane: "api", label: "protected call", style: "solid", semantics: "token" },
      { id: `${name}-e3`, fromLane: "api", toLane: "store", label: "validation", style: "dashed", semantics: "introspection" },
    ],
    flows: {
      ...emptyFlows,
      happy: [
        {
          id: `${name}-h1`,
          title: "Authenticate",
          caption: "Client authenticates through auth server over TLS.",
          activeEdges: [`${name}-e1`],
          activeLanes: ["client", "auth"],
        },
        {
          id: `${name}-h2`,
          title: "Call API",
          caption: "Client calls API and API validates authorization data.",
          activeEdges: [`${name}-e2`, `${name}-e3`],
          activeLanes: ["client", "api", "store"],
        },
      ],
    },
  }
}

const sessionCookiesDiagram: Diagram = {
  lanes: defaultLanes,
  edges: [
    { id: "sc-user-submit", fromLane: "user", toLane: "client", label: "login form submit", style: "solid" },
    { id: "sc-client-auth", fromLane: "client", toLane: "auth", label: "verify credentials", style: "solid", semantics: "code" },
    { id: "sc-auth-store-create", fromLane: "auth", toLane: "store", label: "create session", style: "solid" },
    { id: "sc-auth-client-cookie", fromLane: "auth", toLane: "client", label: "Set-Cookie sid", style: "solid", semantics: "cookie" },
    { id: "sc-client-api-cookie", fromLane: "client", toLane: "api", label: "Cookie: sid=...", style: "solid", semantics: "cookie" },
    { id: "sc-api-store-lookup", fromLane: "api", toLane: "store", label: "session lookup", style: "dashed", semantics: "introspection" },
    { id: "sc-user-client-csrf", fromLane: "user", toLane: "client", label: "forged request", style: "dashed" },
    { id: "sc-auth-store-delete", fromLane: "auth", toLane: "store", label: "invalidate session", style: "solid" },
  ],
  flows: {
    ...emptyFlows,
    happy: [
      {
        id: "sc-h1",
        title: "User submits login",
        caption: "Browser posts credentials to the app backend.",
        activeEdges: ["sc-user-submit"],
        activeLanes: ["user", "client"],
        request: "POST /login\nContent-Type: application/x-www-form-urlencoded",
      },
      {
        id: "sc-h2",
        title: "Credentials verified",
        caption: "Backend validates credentials with auth subsystem.",
        activeEdges: ["sc-client-auth"],
        activeLanes: ["client", "auth"],
      },
      {
        id: "sc-h3",
        title: "Session created",
        caption: "Auth writes server-side session state to trusted store.",
        activeEdges: ["sc-auth-store-create"],
        activeLanes: ["auth", "store"],
      },
      {
        id: "sc-h4",
        title: "Cookie issued",
        caption: "Backend returns session cookie with secure attributes.",
        activeEdges: ["sc-auth-client-cookie"],
        activeLanes: ["auth", "client"],
        response: "Set-Cookie: sid=...; HttpOnly; Secure; SameSite=Lax",
      },
      {
        id: "sc-h5",
        title: "Browser calls API",
        caption: "Browser sends cookie automatically on same-site request.",
        activeEdges: ["sc-client-api-cookie"],
        activeLanes: ["client", "api"],
        request: "GET /me\nCookie: sid=...",
      },
      {
        id: "sc-h6",
        title: "Session validated",
        caption: "API checks session state and returns authorized response.",
        activeEdges: ["sc-api-store-lookup"],
        activeLanes: ["api", "store"],
      },
    ],
    refresh: [
      {
        id: "sc-r1",
        title: "Active session request",
        caption: "User makes another request with existing session cookie.",
        activeEdges: ["sc-client-api-cookie"],
        activeLanes: ["client", "api"],
      },
      {
        id: "sc-r2",
        title: "Session activity read",
        caption: "API reads session and confirms it is still valid.",
        activeEdges: ["sc-api-store-lookup"],
        activeLanes: ["api", "store"],
      },
      {
        id: "sc-r3",
        title: "Session metadata update",
        caption: "Auth updates last-seen timestamp and keeps session alive.",
        activeEdges: ["sc-auth-store-create"],
        activeLanes: ["auth", "store"],
      },
      {
        id: "sc-r4",
        title: "Optional cookie refresh",
        caption: "Server can rotate cookie/session id during continuation.",
        activeEdges: ["sc-auth-client-cookie"],
        activeLanes: ["auth", "client"],
      },
    ],
    logout: [
      {
        id: "sc-l1",
        title: "Logout request",
        caption: "Browser posts logout with active cookie.",
        activeEdges: ["sc-client-api-cookie"],
        activeLanes: ["client", "api"],
        request: "POST /logout\nCookie: sid=...",
      },
      {
        id: "sc-l2",
        title: "Session revoked",
        caption: "Auth deletes session state so sid is no longer valid.",
        activeEdges: ["sc-auth-store-delete"],
        activeLanes: ["auth", "store"],
      },
      {
        id: "sc-l3",
        title: "Cookie cleared",
        caption: "Browser receives expired cookie and future requests fail.",
        activeEdges: ["sc-auth-client-cookie"],
        activeLanes: ["auth", "client"],
        response: "Set-Cookie: sid=; Max-Age=0; HttpOnly; Secure; SameSite=Lax",
      },
    ],
    attack: [],
  },
  overlays: [
    {
      id: "csrf",
      label: "CSRF",
      affectedEdges: ["sc-user-client-csrf", "sc-client-api-cookie"],
      annotation: "CSRF here",
      whatBreaks: "Attacker can trigger state-changing request using victim's cookie.",
      mitigation: "Use SameSite, anti-CSRF token, and Origin/Referer validation.",
    },
  ],
}

const jwtDiagram: Diagram = {
  lanes: defaultLanes,
  edges: [
    { id: "jwt-client-auth-authorize", fromLane: "client", toLane: "auth", label: "authorize (PKCE)", style: "solid", semantics: "code" },
    { id: "jwt-auth-client-token", fromLane: "auth", toLane: "client", label: "JWT + refresh", style: "solid", semantics: "token" },
    { id: "jwt-client-api-access", fromLane: "client", toLane: "api", label: "Bearer access JWT", style: "solid", semantics: "token" },
    { id: "jwt-api-store-jwks", fromLane: "api", toLane: "store", label: "JWKS + claims check", style: "dashed", semantics: "introspection" },
    { id: "jwt-client-auth-refresh", fromLane: "client", toLane: "auth", label: "refresh token", style: "solid", semantics: "token" },
    { id: "jwt-auth-client-rotated", fromLane: "auth", toLane: "client", label: "rotated refresh", style: "solid", semantics: "token" },
    { id: "jwt-client-api-replay", fromLane: "client", toLane: "api", label: "replayed JWT", style: "dashed", semantics: "token" },
    { id: "jwt-auth-store-family", fromLane: "auth", toLane: "store", label: "token family state", style: "dashed" },
  ],
  flows: {
    ...emptyFlows,
    happy: [
      {
        id: "jwt-h1",
        title: "Authorization request",
        caption: "Client starts auth flow with PKCE and receives authorization response.",
        activeEdges: ["jwt-client-auth-authorize"],
        activeLanes: ["client", "auth"],
        request: "GET /authorize?...&code_challenge=...&code_challenge_method=S256",
      },
      {
        id: "jwt-h2",
        title: "Token issuance",
        caption: "Auth server returns short-lived access JWT and refresh token.",
        activeEdges: ["jwt-auth-client-token"],
        activeLanes: ["auth", "client"],
        response: "{ access_token: \"eyJ...\", refresh_token: \"rt_...\", expires_in: 600 }",
      },
      {
        id: "jwt-h3",
        title: "Access token request",
        caption: "Client calls API with bearer access token.",
        activeEdges: ["jwt-client-api-access"],
        activeLanes: ["client", "api"],
        request: "Authorization: Bearer eyJ...",
      },
      {
        id: "jwt-h4",
        title: "JWT validation",
        caption: "API validates signature, iss, aud, exp, and scope claims.",
        activeEdges: ["jwt-api-store-jwks"],
        activeLanes: ["api", "store"],
      },
      {
        id: "jwt-h5",
        title: "Token expiry",
        caption: "Access token expires and old token can no longer authorize requests.",
        activeEdges: ["jwt-client-api-access"],
        activeLanes: ["client", "api"],
      },
      {
        id: "jwt-h6",
        title: "Refresh exchange",
        caption: "Client exchanges refresh token for a new access token.",
        activeEdges: ["jwt-client-auth-refresh", "jwt-auth-client-token"],
        activeLanes: ["client", "auth"],
        request: "POST /oauth/token\ngrant_type=refresh_token&refresh_token=rt_...",
      },
      {
        id: "jwt-h7",
        title: "Rotation and reuse detection",
        caption: "Auth rotates refresh token and records token family to detect replay.",
        activeEdges: ["jwt-auth-client-rotated", "jwt-auth-store-family"],
        activeLanes: ["auth", "client", "store"],
        response: "{ access_token: \"eyJ_new\", refresh_token: \"rt_new\" }",
      },
    ],
    refresh: [
      {
        id: "jwt-r1",
        title: "Access token expired",
        caption: "Client receives 401 due to access token expiry.",
        activeEdges: ["jwt-client-api-access"],
        activeLanes: ["client", "api"],
      },
      {
        id: "jwt-r2",
        title: "Refresh token sent",
        caption: "Client sends refresh token to auth server.",
        activeEdges: ["jwt-client-auth-refresh"],
        activeLanes: ["client", "auth"],
      },
      {
        id: "jwt-r3",
        title: "New token pair issued",
        caption: "Auth returns fresh access token and rotated refresh token.",
        activeEdges: ["jwt-auth-client-token", "jwt-auth-client-rotated"],
        activeLanes: ["auth", "client"],
      },
      {
        id: "jwt-r4",
        title: "Token family state updated",
        caption: "Auth updates token family metadata for replay detection.",
        activeEdges: ["jwt-auth-store-family"],
        activeLanes: ["auth", "store"],
      },
    ],
    logout: [
      {
        id: "jwt-l1",
        title: "Logout or compromise signal",
        caption: "Client or security workflow signals logout/revocation.",
        activeEdges: ["jwt-client-auth-refresh"],
        activeLanes: ["client", "auth"],
      },
      {
        id: "jwt-l2",
        title: "Refresh family revoked",
        caption: "Auth marks refresh token family invalid in token store.",
        activeEdges: ["jwt-auth-store-family"],
        activeLanes: ["auth", "store"],
      },
      {
        id: "jwt-l3",
        title: "Subsequent refresh denied",
        caption: "Any further refresh attempt is rejected and user must reauthenticate.",
        activeEdges: ["jwt-client-auth-refresh"],
        activeLanes: ["client", "auth"],
      },
    ],
    attack: [],
  },
  overlays: [
    {
      id: "replay",
      label: "Replay",
      affectedEdges: ["jwt-client-api-replay"],
      annotation: "Replay here",
      whatBreaks: "Stolen JWT is replayed against API until token expiry.",
      mitigation: "Use short access TTL and revoke refresh token family on detection.",
    },
  ],
}

const opaqueDiagram: Diagram = {
  lanes: defaultLanes,
  edges: [
    { id: "op-client-auth-authorize", fromLane: "client", toLane: "auth", label: "authorize", style: "solid", semantics: "code" },
    { id: "op-auth-client-token", fromLane: "auth", toLane: "client", label: "opaque token", style: "solid", semantics: "token" },
    { id: "op-client-api-token", fromLane: "client", toLane: "api", label: "Bearer opaque token", style: "solid", semantics: "token" },
    { id: "op-api-store-introspect", fromLane: "api", toLane: "store", label: "introspection request", style: "dashed", semantics: "introspection" },
    { id: "op-store-api-claims", fromLane: "store", toLane: "api", label: "active + claims", style: "dashed", semantics: "introspection" },
    { id: "op-auth-store-revoke", fromLane: "auth", toLane: "store", label: "central revocation", style: "solid" },
  ],
  flows: {
    ...emptyFlows,
    happy: [
      {
        id: "op-h1",
        title: "Authorization request",
        caption: "Client requests authorization for opaque access token issuance.",
        activeEdges: ["op-client-auth-authorize"],
        activeLanes: ["client", "auth"],
      },
      {
        id: "op-h2",
        title: "Opaque token issued",
        caption: "Auth returns reference token without exposing claims to client.",
        activeEdges: ["op-auth-client-token"],
        activeLanes: ["auth", "client"],
        response: "{ access_token: \"at_ref_9d2f...\", token_type: \"Bearer\" }",
      },
      {
        id: "op-h3",
        title: "Client calls API",
        caption: "Client sends opaque token to API.",
        activeEdges: ["op-client-api-token"],
        activeLanes: ["client", "api"],
        request: "Authorization: Bearer at_ref_9d2f...",
      },
      {
        id: "op-h4",
        title: "Introspection request",
        caption: "API asks token store/introspection service to validate token.",
        activeEdges: ["op-api-store-introspect"],
        activeLanes: ["api", "store"],
      },
      {
        id: "op-h5",
        title: "Active claims returned",
        caption: "Store returns active state and scopes to API.",
        activeEdges: ["op-store-api-claims"],
        activeLanes: ["store", "api"],
        response: "{ active: true, sub: \"user_42\", scope: \"orders:read\" }",
      },
      {
        id: "op-h6",
        title: "Access granted",
        caption: "API authorizes request using introspection response.",
        activeEdges: ["op-client-api-token"],
        activeLanes: ["client", "api"],
      },
    ],
    refresh: [
      {
        id: "op-r1",
        title: "Token near expiry",
        caption: "Client requests refreshed opaque token from auth server.",
        activeEdges: ["op-client-auth-authorize"],
        activeLanes: ["client", "auth"],
      },
      {
        id: "op-r2",
        title: "Replacement token issued",
        caption: "Auth issues replacement token while old token overlap is short.",
        activeEdges: ["op-auth-client-token"],
        activeLanes: ["auth", "client"],
      },
      {
        id: "op-r3",
        title: "API validates new token",
        caption: "API introspects new token and continues request handling.",
        activeEdges: ["op-api-store-introspect", "op-store-api-claims"],
        activeLanes: ["api", "store"],
      },
    ],
    logout: [
      {
        id: "op-l1",
        title: "Revoke token centrally",
        caption: "Auth writes revocation state for the opaque token.",
        activeEdges: ["op-auth-store-revoke"],
        activeLanes: ["auth", "store"],
      },
      {
        id: "op-l2",
        title: "Client tries old token",
        caption: "Client calls API with revoked token.",
        activeEdges: ["op-client-api-token"],
        activeLanes: ["client", "api"],
      },
      {
        id: "op-l3",
        title: "Introspection fails",
        caption: "API introspection reports inactive token and request is denied.",
        activeEdges: ["op-api-store-introspect", "op-store-api-claims"],
        activeLanes: ["api", "store"],
      },
    ],
    attack: [],
  },
}

const oidcDiagram: Diagram = {
  lanes: defaultLanes,
  edges: [
    { id: "oidc-browser-auth", fromLane: "user", toLane: "auth", label: "redirect to login", style: "solid" },
    { id: "oidc-authorize", fromLane: "client", toLane: "auth", label: "authorize + PKCE", style: "solid", semantics: "code" },
    { id: "oidc-auth-client-code", fromLane: "auth", toLane: "client", label: "authorization code", style: "solid", semantics: "code" },
    { id: "oidc-client-auth-token", fromLane: "client", toLane: "auth", label: "code_verifier exchange", style: "solid", semantics: "code" },
    { id: "oidc-auth-client-token", fromLane: "auth", toLane: "client", label: "id_token + access + refresh", style: "solid", semantics: "token" },
    { id: "oidc-client-api", fromLane: "client", toLane: "api", label: "access token", style: "solid", semantics: "token" },
    { id: "oidc-api-store", fromLane: "api", toLane: "store", label: "claims/JWKS", style: "dashed", semantics: "introspection" },
    { id: "oidc-client-auth-refresh", fromLane: "client", toLane: "auth", label: "refresh grant", style: "solid", semantics: "token" },
    { id: "oidc-client-api-replay", fromLane: "client", toLane: "api", label: "stolen bearer token", style: "dashed", semantics: "token" },
  ],
  flows: {
    ...emptyFlows,
    happy: [
      {
        id: "oidc-h1",
        title: "User starts sign-in",
        caption: "App redirects browser to identity provider for login.",
        activeEdges: ["oidc-browser-auth"],
        activeLanes: ["user", "auth"],
      },
      {
        id: "oidc-h2",
        title: "Authorize request with PKCE",
        caption: "Client sends authorize request with code challenge and state.",
        activeEdges: ["oidc-authorize"],
        activeLanes: ["client", "auth"],
        request: "GET /authorize?response_type=code&state=...&code_challenge=...&code_challenge_method=S256",
      },
      {
        id: "oidc-h3",
        title: "Authorization code returned",
        caption: "IdP redirects back with short-lived authorization code.",
        activeEdges: ["oidc-auth-client-code"],
        activeLanes: ["auth", "client"],
        response: "302 /callback?code=abc123&state=...",
      },
      {
        id: "oidc-h4",
        title: "Code exchange",
        caption: "Client exchanges code + code_verifier for tokens at token endpoint.",
        activeEdges: ["oidc-client-auth-token", "oidc-auth-client-token"],
        activeLanes: ["client", "auth"],
        request: "POST /oauth/token\ngrant_type=authorization_code&code=abc123&code_verifier=...",
      },
      {
        id: "oidc-h5",
        title: "Identity verified",
        caption: "Client validates ID token claims and nonce before trusting identity.",
        activeEdges: ["oidc-auth-client-token"],
        activeLanes: ["client", "auth"],
      },
      {
        id: "oidc-h6",
        title: "Access API",
        caption: "Client calls API with access token.",
        activeEdges: ["oidc-client-api"],
        activeLanes: ["client", "api", "store"],
        request: "Authorization: Bearer eyJ...",
      },
      {
        id: "oidc-h7",
        title: "API validates token",
        caption: "API checks JWT signature, audience, expiry, and scopes via JWKS cache.",
        activeEdges: ["oidc-api-store"],
        activeLanes: ["api", "store"],
      },
    ],
    refresh: [
      {
        id: "oidc-r1",
        title: "Access token expires",
        caption: "API rejects expired access token with 401.",
        activeEdges: ["oidc-client-api"],
        activeLanes: ["client", "api"],
      },
      {
        id: "oidc-r2",
        title: "Refresh token exchange",
        caption: "Client sends refresh token for new access token.",
        activeEdges: ["oidc-client-auth-refresh", "oidc-auth-client-token"],
        activeLanes: ["client", "auth"],
        request: "POST /oauth/token\ngrant_type=refresh_token&refresh_token=rt_...",
      },
      {
        id: "oidc-r3",
        title: "API call resumes",
        caption: "Client retries API call with fresh access token.",
        activeEdges: ["oidc-client-api"],
        activeLanes: ["client", "api"],
      },
    ],
    logout: [
      {
        id: "oidc-l1",
        title: "Logout requested",
        caption: "Client initiates RP logout and clears local session.",
        activeEdges: ["oidc-client-auth-refresh"],
        activeLanes: ["client", "auth"],
      },
      {
        id: "oidc-l2",
        title: "Refresh token revoked",
        caption: "IdP invalidates refresh token so new access tokens cannot be minted.",
        activeEdges: ["oidc-client-auth-refresh"],
        activeLanes: ["client", "auth"],
      },
      {
        id: "oidc-l3",
        title: "Reauthentication required",
        caption: "Any further API access requires full sign-in again.",
        activeEdges: ["oidc-client-api"],
        activeLanes: ["client", "api"],
      },
    ],
    attack: [],
  },
  overlays: [
    {
      id: "token-theft",
      label: "Token theft",
      affectedEdges: ["oidc-client-api-replay"],
      annotation: "Token replayed",
      whatBreaks: "Stolen bearer token is reused against API until expiry.",
      mitigation: "Use short access TTL, sender-constrained tokens where possible, and rapid revocation.",
    },
  ],
}

const oauth2Diagram: Diagram = {
  lanes: defaultLanes,
  edges: [
    { id: "oa-user-auth-consent", fromLane: "user", toLane: "auth", label: "user login + consent", style: "solid" },
    { id: "oa-client-auth-authorize", fromLane: "client", toLane: "auth", label: "authorize?scope=read:orders", style: "solid", semantics: "code" },
    { id: "oa-auth-client-code", fromLane: "auth", toLane: "client", label: "redirect with auth code", style: "solid", semantics: "code" },
    { id: "oa-client-auth-token", fromLane: "client", toLane: "auth", label: "token exchange (code)", style: "solid", semantics: "code" },
    { id: "oa-auth-client-access", fromLane: "auth", toLane: "client", label: "access token issued", style: "solid", semantics: "token" },
    { id: "oa-client-api-call", fromLane: "client", toLane: "api", label: "Bearer access token", style: "solid", semantics: "token" },
    { id: "oa-api-store-check", fromLane: "api", toLane: "store", label: "scope check / introspect", style: "dashed", semantics: "introspection" },
  ],
  flows: {
    ...emptyFlows,
    happy: [
      {
        id: "oa-h1",
        title: "Auth request with scopes",
        caption: "Client starts OAuth with explicit scopes for delegated access.",
        activeEdges: ["oa-client-auth-authorize"],
        activeLanes: ["client", "auth"],
        request: "GET /authorize?response_type=code&scope=read:orders&state=...",
      },
      {
        id: "oa-h2",
        title: "User consents",
        caption: "Authorization server authenticates user and presents requested scopes.",
        activeEdges: ["oa-user-auth-consent"],
        activeLanes: ["user", "auth"],
      },
      {
        id: "oa-h3",
        title: "Authorization code returned",
        caption: "Auth server redirects back with a short-lived authorization code.",
        activeEdges: ["oa-auth-client-code"],
        activeLanes: ["auth", "client"],
        response: "302 /callback?code=abc123&state=...",
      },
      {
        id: "oa-h4",
        title: "Code exchanged for token",
        caption: "Client exchanges code at token endpoint and receives access token.",
        activeEdges: ["oa-client-auth-token", "oa-auth-client-access"],
        activeLanes: ["client", "auth"],
        request: "POST /token\ngrant_type=authorization_code&code=abc123",
        response: "{ access_token: \"at_...\", token_type: \"Bearer\", scope: \"read:orders\" }",
      },
      {
        id: "oa-h5",
        title: "API called with bearer token",
        caption: "Client calls resource server using delegated access token.",
        activeEdges: ["oa-client-api-call"],
        activeLanes: ["client", "api"],
        request: "Authorization: Bearer at_...",
      },
      {
        id: "oa-h6",
        title: "Scope is enforced",
        caption: "API validates scopes directly or via introspection before serving data.",
        activeEdges: ["oa-api-store-check"],
        activeLanes: ["api", "store"],
      },
    ],
    refresh: [],
    logout: [],
    attack: [],
  },
}

const samlDiagram: Diagram = {
  lanes: defaultLanes,
  edges: [
    { id: "sa-user-sp", fromLane: "user", toLane: "client", label: "visit app", style: "solid" },
    { id: "sa-client-user-redirect", fromLane: "client", toLane: "user", label: "302 to IdP", style: "solid" },
    { id: "sa-user-idp-redirect", fromLane: "user", toLane: "auth", label: "HTTP-Redirect AuthnRequest", style: "solid" },
    { id: "sa-auth-user-post", fromLane: "auth", toLane: "user", label: "HTTP-POST SAMLResponse", style: "solid" },
    { id: "sa-user-client-acs", fromLane: "user", toLane: "client", label: "POST /saml/acs", style: "solid" },
    { id: "sa-auth-client-assert", fromLane: "auth", toLane: "client", label: "signed assertion check", style: "dashed" },
    { id: "sa-client-store-session", fromLane: "client", toLane: "store", label: "create SP session", style: "solid" },
    { id: "sa-client-api-cookie", fromLane: "client", toLane: "api", label: "session cookie", style: "solid", semantics: "cookie" },
    { id: "sa-api-store-lookup", fromLane: "api", toLane: "store", label: "session lookup", style: "dashed", semantics: "introspection" },
    { id: "sa-client-auth-slo", fromLane: "client", toLane: "auth", label: "Single Logout", style: "solid" },
  ],
  flows: {
    ...emptyFlows,
    happy: [
      {
        id: "sa-h1",
        title: "User hits service provider",
        caption: "User opens app and SP sees no active session. Notice: browser is just the courier.",
        activeEdges: ["sa-user-sp"],
        activeLanes: ["user", "client"],
      },
      {
        id: "sa-h2",
        title: "SP issues redirect to IdP",
        caption: "SP creates AuthnRequest and sends 302 redirect. Notice: request binding is HTTP-Redirect.",
        activeEdges: ["sa-client-user-redirect"],
        activeLanes: ["client", "user"],
      },
      {
        id: "sa-h3",
        title: "Browser forwards AuthnRequest",
        caption: "Browser lands on IdP with AuthnRequest parameters. Notice: user agent carries protocol messages.",
        activeEdges: ["sa-user-idp-redirect"],
        activeLanes: ["client", "auth"],
      },
      {
        id: "sa-h4",
        title: "IdP authenticates and prepares assertion",
        caption: "IdP authenticates user and signs SAMLResponse assertion. Notice: signature and audience must be strict.",
        activeEdges: ["sa-auth-client-assert"],
        activeLanes: ["auth", "client"],
      },
      {
        id: "sa-h5",
        title: "SAMLResponse posted to ACS",
        caption: "IdP sends SAMLResponse to browser which POSTs to SP ACS endpoint. Notice: this is HTTP-POST binding.",
        activeEdges: ["sa-auth-user-post", "sa-user-client-acs"],
        activeLanes: ["auth", "user", "client"],
      },
      {
        id: "sa-h6",
        title: "SP validates response details",
        caption: "SP validates signature, audience, InResponseTo, and time window. Notice: replay protection belongs here.",
        activeEdges: ["sa-auth-client-assert"],
        activeLanes: ["client", "auth"],
      },
      {
        id: "sa-h7",
        title: "SP session created",
        caption: "SP issues secure session cookie after assertion validation. Notice: set cookie flags and lifetime.",
        activeEdges: ["sa-client-store-session", "sa-client-api-cookie"],
        activeLanes: ["client", "store", "api"],
      },
      {
        id: "sa-h8",
        title: "App request authorized",
        caption: "App reads SP session and serves protected route. Notice: IdP assertion is now translated to SP session.",
        activeEdges: ["sa-api-store-lookup"],
        activeLanes: ["api", "store"],
      },
    ],
    refresh: [],
    logout: [
      {
        id: "sa-l1",
        title: "User initiates logout",
        caption: "SP initiates SAML Single Logout with IdP. Notice: logout coordination spans SP and IdP sessions.",
        activeEdges: ["sa-client-auth-slo"],
        activeLanes: ["client", "auth"],
      },
      {
        id: "sa-l2",
        title: "SP session cleared",
        caption: "SP removes local session and expires cookie. Notice: local cleanup must be immediate.",
        activeEdges: ["sa-client-store-session"],
        activeLanes: ["client", "store"],
      },
      {
        id: "sa-l3",
        title: "Further app access blocked",
        caption: "Requests without new assertion-backed session are denied. Notice: reauth is required.",
        activeEdges: ["sa-client-api-cookie"],
        activeLanes: ["client", "api"],
      },
    ],
    attack: [],
  },
}

const apiKeysDiagram: Diagram = {
  lanes: defaultLanes,
  edges: [
    { id: "ak-client-api-key", fromLane: "client", toLane: "api", label: "X-API-Key", style: "solid", semantics: "token" },
    { id: "ak-api-store-lookup", fromLane: "api", toLane: "store", label: "key lookup + scope", style: "dashed", semantics: "introspection" },
    { id: "ak-api-store-rate", fromLane: "api", toLane: "store", label: "rate limit check", style: "dashed" },
    { id: "ak-api-client-response", fromLane: "api", toLane: "client", label: "authorized response", style: "solid" },
    { id: "ak-auth-store-rotate", fromLane: "auth", toLane: "store", label: "key rotate/revoke", style: "solid" },
  ],
  flows: {
    ...emptyFlows,
    happy: [
      {
        id: "ak-h1",
        title: "Client sends API key",
        caption: "Server-side client sends scoped API key over TLS.",
        activeEdges: ["ak-client-api-key"],
        activeLanes: ["client", "api"],
      },
      {
        id: "ak-h2",
        title: "Key lookup and scope check",
        caption: "API validates key hash, owner, and allowed scopes.",
        activeEdges: ["ak-api-store-lookup"],
        activeLanes: ["api", "store"],
      },
      {
        id: "ak-h3",
        title: "Rate limit enforcement",
        caption: "API enforces per-key throttling before processing.",
        activeEdges: ["ak-api-store-rate"],
        activeLanes: ["api", "store"],
      },
      {
        id: "ak-h4",
        title: "Request served",
        caption: "API returns data when scope and limits are valid.",
        activeEdges: ["ak-api-client-response"],
        activeLanes: ["api", "client"],
      },
      {
        id: "ak-h5",
        title: "Operational rotation",
        caption: "Auth/ops rotates key and revokes stale secrets regularly.",
        activeEdges: ["ak-auth-store-rotate"],
        activeLanes: ["auth", "store"],
      },
    ],
    refresh: [],
    logout: [],
    attack: [],
  },
}

const basicAuthDiagram: Diagram = {
  lanes: defaultLanes,
  edges: [
    { id: "ba-client-api-header", fromLane: "client", toLane: "api", label: "Authorization: Basic ...", style: "solid" },
    { id: "ba-api-store-verify", fromLane: "api", toLane: "store", label: "credential verify", style: "dashed" },
    { id: "ba-api-client-response", fromLane: "api", toLane: "client", label: "allow/deny", style: "solid" },
    { id: "ba-auth-store-rotate", fromLane: "auth", toLane: "store", label: "password rotation", style: "solid" },
    { id: "ba-api-store-rate", fromLane: "api", toLane: "store", label: "rate limit", style: "dashed" },
  ],
  flows: {
    ...emptyFlows,
    happy: [
      {
        id: "ba-h1",
        title: "Client sends Basic header",
        caption: "Internal service sends base64 credentials over TLS.",
        activeEdges: ["ba-client-api-header"],
        activeLanes: ["client", "api"],
      },
      {
        id: "ba-h2",
        title: "Credential verification",
        caption: "API validates credentials against credential store.",
        activeEdges: ["ba-api-store-verify"],
        activeLanes: ["api", "store"],
      },
      {
        id: "ba-h3",
        title: "Rate limiting check",
        caption: "API enforces brute-force protection before response.",
        activeEdges: ["ba-api-store-rate"],
        activeLanes: ["api", "store"],
      },
      {
        id: "ba-h4",
        title: "Resource response",
        caption: "API serves request if credentials and limits pass.",
        activeEdges: ["ba-api-client-response"],
        activeLanes: ["api", "client"],
      },
      {
        id: "ba-h5",
        title: "Credential rotation",
        caption: "Operations rotates passwords to limit blast radius.",
        activeEdges: ["ba-auth-store-rotate"],
        activeLanes: ["auth", "store"],
      },
    ],
    refresh: [],
    logout: [],
    attack: [],
  },
}

const mtlsDiagram: Diagram = {
  lanes: defaultLanes,
  edges: [
    { id: "mt-client-auth-csr", fromLane: "client", toLane: "auth", label: "CSR/cert request", style: "solid" },
    { id: "mt-auth-client-cert", fromLane: "auth", toLane: "client", label: "issued client cert", style: "solid" },
    { id: "mt-client-api-handshake", fromLane: "client", toLane: "api", label: "mTLS handshake", style: "solid" },
    { id: "mt-api-store-trust", fromLane: "api", toLane: "store", label: "trust chain / revocation", style: "dashed" },
    { id: "mt-client-api-request", fromLane: "client", toLane: "api", label: "authenticated request", style: "solid" },
    { id: "mt-client-auth-rotate", fromLane: "client", toLane: "auth", label: "cert rotation", style: "solid" },
  ],
  flows: {
    ...emptyFlows,
    happy: [
      {
        id: "mt-h1",
        title: "Workload requests certificate",
        caption: "Service sends CSR to certificate authority/issuer.",
        activeEdges: ["mt-client-auth-csr"],
        activeLanes: ["client", "auth"],
      },
      {
        id: "mt-h2",
        title: "Issuer returns client certificate",
        caption: "Issuer signs and returns short-lived client certificate.",
        activeEdges: ["mt-auth-client-cert"],
        activeLanes: ["auth", "client"],
      },
      {
        id: "mt-h3",
        title: "mTLS handshake",
        caption: "Client and API mutually authenticate using certificates.",
        activeEdges: ["mt-client-api-handshake"],
        activeLanes: ["client", "api"],
      },
      {
        id: "mt-h4",
        title: "Trust and revocation checks",
        caption: "API validates trust chain and revocation state.",
        activeEdges: ["mt-api-store-trust"],
        activeLanes: ["api", "store"],
      },
      {
        id: "mt-h5",
        title: "Identity-bound request",
        caption: "Request is accepted with certificate-bound service identity.",
        activeEdges: ["mt-client-api-request"],
        activeLanes: ["client", "api"],
      },
      {
        id: "mt-h6",
        title: "Automated certificate rotation",
        caption: "Service periodically rotates certificates before expiry.",
        activeEdges: ["mt-client-auth-rotate", "mt-auth-client-cert"],
        activeLanes: ["client", "auth"],
      },
    ],
    refresh: [],
    logout: [],
    attack: [],
  },
}

const hmacDiagram: Diagram = {
  lanes: defaultLanes,
  edges: [
    { id: "hm-client-canonicalize", fromLane: "client", toLane: "auth", label: "canonical request string", style: "dashed" },
    { id: "hm-client-api-signed", fromLane: "client", toLane: "api", label: "signed request", style: "solid" },
    { id: "hm-api-store-secret", fromLane: "api", toLane: "store", label: "secret lookup", style: "dashed" },
    { id: "hm-api-store-replay", fromLane: "api", toLane: "store", label: "nonce/timestamp check", style: "dashed" },
    { id: "hm-store-api-verify", fromLane: "store", toLane: "api", label: "signature verify result", style: "dashed" },
    { id: "hm-api-client-response", fromLane: "api", toLane: "client", label: "allow/deny", style: "solid" },
  ],
  flows: {
    ...emptyFlows,
    happy: [
      {
        id: "hm-h1",
        title: "Canonical string built",
        caption: "Client canonicalizes method, path, body hash, nonce, and timestamp.",
        activeEdges: ["hm-client-canonicalize"],
        activeLanes: ["client", "auth"],
      },
      {
        id: "hm-h2",
        title: "Request signed with shared secret",
        caption: "Client computes HMAC signature and sends signed headers.",
        activeEdges: ["hm-client-api-signed"],
        activeLanes: ["client", "api"],
      },
      {
        id: "hm-h3",
        title: "Server loads secret",
        caption: "API fetches caller secret material from secure store.",
        activeEdges: ["hm-api-store-secret"],
        activeLanes: ["api", "store"],
      },
      {
        id: "hm-h4",
        title: "Replay checks performed",
        caption: "API validates nonce and timestamp window to block replay.",
        activeEdges: ["hm-api-store-replay"],
        activeLanes: ["api", "store"],
      },
      {
        id: "hm-h5",
        title: "Signature verified",
        caption: "Server recomputes HMAC and compares signatures in constant time.",
        activeEdges: ["hm-store-api-verify"],
        activeLanes: ["store", "api"],
      },
      {
        id: "hm-h6",
        title: "Request accepted",
        caption: "API processes request only if signature and replay checks pass.",
        activeEdges: ["hm-api-client-response"],
        activeLanes: ["api", "client"],
      },
    ],
    refresh: [],
    logout: [],
    attack: [],
  },
}

const rawAuthMethods: AuthMethod[] = [
  {
    id: "session-cookies",
    name: "Session Cookies",
    category: "Session",
    supportedVariants: ["happy", "refresh", "logout"],
    tagline: "Server-owned sessions for browser apps with tight revocation control.",
    bestFor: ["saas-web-app", "internal-legacy"],
    avoidFor: ["service-to-service", "third-party-api"],
    useWhen: ["Browser apps with backend", "You need immediate server-side revocation"],
    dontUseWhen: ["Public 3rd-party API auth", "Pure cross-domain SPA without BFF"],
    pros: ["Central control", "Easy logout", "Simple browser UX"],
    cons: ["Needs CSRF protection", "Cross-site complexity"],
    gotchas: ["Set HttpOnly + Secure + SameSite", "CSRF token/origin checks on unsafe methods"],
    gotcha: "Cookies need HttpOnly, Secure, SameSite, and CSRF protection together to stay safe.",
    commonMistakes: ["Skipping CSRF", "Overly long sessions"],
    regretLine: "Teams regret this when they expand to public/mobile clients without a migration plan.",
    securityChecklist: [
      "HttpOnly, Secure, explicit SameSite",
      "CSRF defense pattern",
      "Session rotation on login",
      "Idle and absolute timeout",
      "Rate limits on login and session endpoints",
    ],
    tradeoffMeters: { complexity: 38, revocationEase: 86, browserSafety: 78, debuggability: 72 },
    whenToUse: {
      bestFor: ["saas-web-app", "internal-legacy"],
      worksIf: ["high-regulation", "enterprise-sso"],
      avoid: ["spa-public-api", "service-to-service"],
    },
    prosChips: ["Server control", "Fast logout", "Simple browser UX", "Mature tooling", "Centralized policy"],
    consChips: ["Needs CSRF defense", "Cross-site friction", "Session store ops", "Scaling stateful tier", "Mobile mismatch"],
    commonMistake: "Teams skip SameSite + anti-CSRF tokens and assume HttpOnly alone is enough.",
    diagram: sessionCookiesDiagram,
    flowLabels: { happy: "Happy path", refresh: "Continuation", logout: "Logout / revocation" },
  },
  {
    id: "api-keys",
    name: "API Keys",
    category: "Token",
    supportedVariants: ["happy"],
    tagline: "Machine integrations only. Never in browsers; always use TLS and key rotation.",
    bestFor: ["third-party-api", "internal-legacy"],
    avoidFor: ["saas-web-app", "enterprise-sso"],
    useWhen: ["Server-to-server integrations", "Low-friction onboarding"],
    dontUseWhen: ["End-user login identity", "Untrusted browser clients"],
    pros: ["Simple", "Low protocol overhead"],
    cons: ["Leak impact high", "Limited user-level context"],
    gotchas: ["Hash at rest", "Scope per key", "Plan rotation"],
    commonMistakes: ["One shared key for all customers"],
    regretLine: "Regret appears when delegated consent and user context become mandatory.",
    securityChecklist: ["Hash keys", "Per-key scopes", "Rotation", "Rate limits", "Revocation"],
    tradeoffMeters: { complexity: 22, revocationEase: 54, browserSafety: 30, debuggability: 76 },
    whenToUse: {
      bestFor: ["third-party-api", "internal-legacy"],
      worksIf: ["service-to-service"],
      avoid: ["saas-web-app", "enterprise-sso"],
    },
    prosChips: ["Simple onboarding", "Low protocol cost", "Good for machines", "Easy to issue", "Cheap to run"],
    consChips: ["Leak blast radius", "Weak user context", "Manual rotation burden", "Key sprawl", "Audit gaps"],
    commonMistake: "Using one global key per environment instead of per-client scoped keys.",
    gotcha: "Treat API keys as secrets: scope them, rotate them, and rate-limit every key.",
    diagram: apiKeysDiagram,
  },
  {
    id: "basic-auth",
    name: "Basic Auth",
    category: "Token",
    supportedVariants: ["happy"],
    tagline: "Legacy internal only. Never in browsers.",
    bestFor: ["internal-legacy"],
    avoidFor: ["saas-web-app", "mobile-app", "third-party-api", "enterprise-sso"],
    useWhen: ["Temporary bridge in controlled internal networks"],
    dontUseWhen: ["Internet-facing auth", "Modern delegated auth"],
    pros: ["Simple"],
    cons: ["Credentials sent every request", "Weak lifecycle controls"],
    gotchas: ["TLS required", "Migrate off quickly"],
    commonMistakes: ["Using it in browser apps"],
    regretLine: "Migration debt compounds quickly.",
    securityChecklist: ["TLS", "Rate limiting", "Rotation", "Audit logs"],
    tradeoffMeters: { complexity: 12, revocationEase: 25, browserSafety: 15, debuggability: 68 },
    whenToUse: {
      bestFor: ["internal-legacy"],
      worksIf: ["service-to-service"],
      avoid: ["saas-web-app", "mobile-app", "third-party-api"],
    },
    prosChips: ["Very simple", "Universal support", "Quick bridge", "Low setup", "Debuggable"],
    consChips: ["Credential replay", "No fine-grained revocation", "Bad browser fit", "Weak delegation", "Operational debt"],
    commonMistake: "Leaving Basic Auth in production APIs instead of scheduling a migration deadline.",
    gotcha: "Basic Auth is legacy: internal-only, TLS-only, and never for browser clients.",
    diagram: basicAuthDiagram,
  },
  {
    id: "bearer-tokens",
    name: "Bearer Tokens (Concept)",
    category: "Token",
    tagline: "Handle like cash. If it leaks, assume it is already used.",
    bestFor: ["spa-public-api", "mobile-app", "third-party-api"],
    avoidFor: ["internal-legacy"],
    useWhen: ["You need stateless API auth"],
    dontUseWhen: ["You need immediate revocation with no server checks"],
    pros: ["Simple API contract"],
    cons: ["Possession equals access"],
    gotchas: ["Choose JWT vs opaque intentionally"],
    commonMistakes: ["Long-lived bearer tokens in frontend storage"],
    regretLine: "Regret comes from weak rotation and revocation design.",
    securityChecklist: ["Short lifetimes", "Audience validation", "Storage hardening"],
    tradeoffMeters: { complexity: 34, revocationEase: 42, browserSafety: 33, debuggability: 58 },
    whenToUse: {
      bestFor: ["spa-public-api", "mobile-app", "third-party-api"],
      worksIf: ["saas-web-app"],
      avoid: ["internal-legacy"],
    },
    prosChips: ["Simple API contract", "Wide interoperability", "Fast transport", "Flexible formats", "Works across domains"],
    consChips: ["Leak = access", "Revocation challenges", "Storage risk in browser", "Replay risk", "Scope overreach"],
    commonMistake: "Treating bearer tokens like identity proof instead of pure possession credentials.",
    relatedMethodIds: ["jwt-refresh", "opaque-tokens"],
    diagram: stubDiagram("bearer"),
  },
  {
    id: "jwt-refresh",
    name: "JWT Access + Refresh Tokens",
    category: "Token",
    supportedVariants: ["happy", "refresh", "logout"],
    tagline: "Scalable token pattern with strict refresh rotation discipline.",
    bestFor: ["spa-public-api", "mobile-app", "saas-web-app"],
    avoidFor: ["service-to-service"],
    useWhen: ["You need scalable API auth with short-lived access tokens"],
    dontUseWhen: ["You cannot run rotation + reuse detection"],
    pros: ["Fast validation", "Broad ecosystem support"],
    cons: ["Revocation complexity"],
    gotchas: ["Validate iss/aud/exp", "Do refresh reuse detection"],
    gotcha: "Refresh rotation without reuse detection still leaves replay windows open.",
    commonMistakes: ["Long access token lifetimes"],
    regretLine: "Teams regret it when they optimize for statelessness over incident response.",
    securityChecklist: ["Short TTL", "Refresh rotation", "Key rotation", "Revocation"],
    tradeoffMeters: { complexity: 68, revocationEase: 48, browserSafety: 52, debuggability: 46 },
    whenToUse: {
      bestFor: ["spa-public-api", "mobile-app", "saas-web-app"],
      worksIf: ["third-party-api"],
      avoid: ["service-to-service"],
    },
    prosChips: ["Scales well", "Fast local validation", "Strong ecosystem", "Good mobile fit", "Flexible claims"],
    consChips: ["Revocation complexity", "Rotation discipline required", "Claim misuse risk", "Harder incident response", "Clock skew issues"],
    commonMistake: "Keeping access tokens long-lived and skipping refresh token reuse detection.",
    diagram: jwtDiagram,
    flowLabels: { happy: "Happy path", refresh: "Refresh", logout: "Logout / revocation" },
  },
  {
    id: "opaque-tokens",
    name: "Opaque Tokens",
    category: "Token",
    supportedVariants: ["happy", "refresh", "logout"],
    tagline: "Reference tokens with central introspection and revocation.",
    bestFor: ["high-regulation", "third-party-api", "service-to-service", "mobile-app"],
    avoidFor: ["internal-legacy"],
    useWhen: ["You need central policy and fast revocation"],
    dontUseWhen: ["You cannot afford introspection dependency"],
    pros: ["Strong revocation", "No exposed claims"],
    cons: ["Runtime introspection cost"],
    gotchas: ["Cache introspection results carefully"],
    gotcha: "Over-caching introspection can silently weaken your revocation guarantees.",
    commonMistakes: ["No caching or over-caching"],
    regretLine: "Regret is usually unplanned auth-server latency dependency.",
    securityChecklist: ["Introspection auth", "Short expiry", "Audit logs"],
    tradeoffMeters: { complexity: 62, revocationEase: 88, browserSafety: 60, debuggability: 64 },
    whenToUse: {
      bestFor: ["high-regulation", "third-party-api", "service-to-service", "mobile-app"],
      worksIf: ["saas-web-app"],
      avoid: ["internal-legacy"],
    },
    prosChips: ["Central revocation", "Policy control", "No exposed claims", "Strong audit fit", "Fine-grained decisions"],
    consChips: ["Introspection latency", "Auth dependency at runtime", "Cache tuning needed", "More infra moving parts", "Token server scaling"],
    commonMistake: "Caching introspection too long and defeating fast revocation benefits.",
    diagram: opaqueDiagram,
    flowLabels: { happy: "Happy path", refresh: "Continuation", logout: "Revocation" },
  },
  {
    id: "oauth2",
    name: "OAuth 2.0",
    category: "SSO",
    supportedVariants: ["happy"],
    tagline: "Delegated authorization framework. Not authentication on its own.",
    bestFor: ["third-party-api", "enterprise-sso", "mobile-app"],
    avoidFor: ["internal-legacy"],
    useWhen: ["You need delegated API access and consent"],
    dontUseWhen: ["You only need simple first-party login"],
    pros: ["Standardized delegation", "Scope controls"],
    cons: ["Complexity"],
    gotchas: ["For login, use OIDC", "Prefer Code + PKCE for browser apps", "Avoid Implicit default"],
    commonMistakes: ["Confusing authorization with authentication"],
    regretLine: "Confusion between OAuth and identity creates fragile login systems.",
    securityChecklist: ["State validation", "PKCE", "Redirect URI restrictions"],
    tradeoffMeters: { complexity: 74, revocationEase: 55, browserSafety: 58, debuggability: 44 },
    whenToUse: {
      bestFor: ["third-party-api", "enterprise-sso", "mobile-app"],
      worksIf: ["saas-web-app"],
      avoid: ["internal-legacy"],
    },
    prosChips: ["Delegation standard", "Scopes and consent", "Ecosystem support", "Provider interoperability", "Mature patterns"],
    consChips: ["Protocol complexity", "Easy to misconfigure", "Not login by itself", "Token lifecycle burden", "Redirect pitfalls"],
    commonMistake: "Using OAuth alone for login identity instead of pairing with OIDC.",
    gotcha: "OAuth 2.0 is authorization, not authentication; use OIDC for login identity.",
    diagram: oauth2Diagram,
  },
  {
    id: "oidc",
    name: "OpenID Connect (OIDC)",
    category: "SSO",
    supportedVariants: ["happy", "refresh", "logout"],
    tagline: "Identity layer on OAuth for real login and user identity claims.",
    bestFor: ["saas-web-app", "spa-public-api", "mobile-app", "enterprise-sso"],
    avoidFor: ["internal-legacy"],
    useWhen: ["You need standards-based login identity"],
    dontUseWhen: ["You cannot validate tokens correctly"],
    pros: ["Strong identity model", "Federation ready"],
    cons: ["More moving parts"],
    gotchas: ["Use Authorization Code + PKCE", "Implicit should not be default"],
    gotcha: "Skipping nonce/state validation is where most OIDC breaches begin.",
    commonMistakes: ["Using OAuth access token as identity proof"],
    regretLine: "Most failures are from validation shortcuts, not the protocol.",
    securityChecklist: ["Validate iss/aud/nonce", "Exact redirect URI matching", "Key rotation"],
    tradeoffMeters: { complexity: 72, revocationEase: 58, browserSafety: 74, debuggability: 52 },
    whenToUse: {
      bestFor: ["saas-web-app", "spa-public-api", "mobile-app", "enterprise-sso"],
      worksIf: ["third-party-api"],
      avoid: ["internal-legacy"],
    },
    prosChips: ["Identity standard", "Federation ready", "PKCE for public clients", "Strong token model", "Broad IdP support"],
    consChips: ["Many moving parts", "Claim validation errors", "Configuration heavy", "Logout nuances", "Provider variance"],
    commonMistake: "Skipping nonce/state checks and then trusting tokens too early in browser flows.",
    diagram: oidcDiagram,
    flowLabels: { happy: "Happy path", refresh: "Refresh", logout: "Logout", attack: "Failure" },
  },
  {
    id: "saml",
    name: "SAML",
    category: "SSO",
    tagline: "Enterprise browser SSO with signed XML assertions.",
    bestFor: ["Enterprise SSO rollout", "B2B SaaS tenant SSO", "Legacy enterprise web apps"],
    avoidFor: ["Mobile-native auth", "Public SPA without backend"],
    supportedVariants: ["happy", "logout"],
    useWhen: ["Enterprise tenants require it"],
    dontUseWhen: ["Greenfield API-first auth"],
    pros: ["Enterprise compatibility"],
    cons: ["XML complexity"],
    gotchas: ["Signature and audience checks"],
    commonMistakes: ["Weak metadata lifecycle"],
    regretLine: "Operational overhead grows per tenant.",
    securityChecklist: ["Strict signature validation", "Metadata lifecycle"],
    tradeoffMeters: { complexity: 82, revocationEase: 57, browserSafety: 70, debuggability: 36 },
    whenToUse: {
      bestFor: ["enterprise-sso"],
      worksIf: ["high-regulation"],
      avoid: ["mobile-app", "service-to-service"],
    },
    prosChips: ["Enterprise compatibility", "Mature federation", "Strong assertion model", "Tenant familiarity", "Compliance friendly"],
    consChips: ["XML complexity", "Verbose payloads", "Metadata drift", "Operational overhead", "Hard local debugging"],
    commonMistake: "Treating metadata and cert rollover as one-time setup instead of ongoing operations.",
    gotcha: "SAML security depends on strict signature, audience, and time-window validation.",
    diagram: samlDiagram,
    flowLabels: { happy: "Happy path", logout: "Logout" },
  },
  {
    id: "mtls",
    name: "mTLS",
    category: "Service",
    supportedVariants: ["happy"],
    tagline: "Mutual TLS identity for service-to-service trust.",
    bestFor: ["service-to-service", "high-regulation"],
    avoidFor: ["saas-web-app", "mobile-app"],
    useWhen: ["Workload identity and zero-trust service meshes"],
    dontUseWhen: ["User login experiences"],
    pros: ["Strong client identity"],
    cons: ["PKI operational burden"],
    gotchas: ["Automate cert rotation"],
    commonMistakes: ["Long-lived certificates"],
    regretLine: "Without PKI automation, complexity overwhelms teams.",
    securityChecklist: ["Short-lived certs", "Revocation checks", "Trust anchor controls"],
    tradeoffMeters: { complexity: 88, revocationEase: 73, browserSafety: 85, debuggability: 40 },
    whenToUse: {
      bestFor: ["service-to-service", "high-regulation"],
      worksIf: ["third-party-api"],
      avoid: ["saas-web-app", "mobile-app"],
    },
    prosChips: ["Strong workload identity", "Mutual trust", "No bearer reuse", "Excellent zero-trust fit", "Protocol-level assurance"],
    consChips: ["PKI burden", "Cert lifecycle complexity", "Hard onboarding", "Rotation outages risk", "Higher ops cost"],
    commonMistake: "Issuing long-lived certificates without automated renewal and revocation drills.",
    gotcha: "mTLS only works long-term when certificate issuance and rotation are automated.",
    diagram: mtlsDiagram,
  },
  {
    id: "hmac-signed",
    name: "HMAC Signed Requests",
    category: "Service",
    supportedVariants: ["happy"],
    tagline: "Tamper-evident API requests with shared secrets.",
    bestFor: ["service-to-service", "third-party-api", "high-regulation"],
    avoidFor: ["saas-web-app", "enterprise-sso"],
    useWhen: ["Server integrations requiring request integrity"],
    dontUseWhen: ["Federated login identity"],
    pros: ["Strong request integrity"],
    cons: ["Canonicalization complexity"],
    gotchas: ["Nonce + timestamp replay protection"],
    commonMistakes: ["No nonce store"],
    regretLine: "Debugging signature mismatch can become expensive quickly.",
    securityChecklist: ["Canonical spec", "Replay window", "Secret rotation"],
    tradeoffMeters: { complexity: 64, revocationEase: 52, browserSafety: 44, debuggability: 50 },
    whenToUse: {
      bestFor: ["service-to-service", "third-party-api", "high-regulation"],
      worksIf: ["internal-legacy"],
      avoid: ["saas-web-app", "enterprise-sso"],
    },
    prosChips: ["Tamper evidence", "No bearer replay without nonce", "Good for partner APIs", "Flexible payload signing", "Strong audit trail"],
    consChips: ["Canonicalization bugs", "Clock skew issues", "Nonce store needed", "Shared secret lifecycle", "Onboarding complexity"],
    commonMistake: "Skipping nonce + timestamp validation and assuming signatures alone prevent replay.",
    gotcha: "HMAC signatures need nonce + timestamp replay checks or attackers can replay valid requests.",
    diagram: hmacDiagram,
  },
]

function normalizeMethod(method: AuthMethod): AuthMethod {
  return {
    ...method,
    description: method.description ?? method.tagline ?? "",
    bestFor: method.bestFor ?? method.whenToUse?.bestFor ?? [],
    avoidWhen: method.avoidWhen ?? method.avoidFor ?? method.whenToUse?.avoid ?? [],
    pros: method.pros ?? method.prosChips ?? [],
    cons: method.cons ?? method.consChips ?? [],
    gotcha: method.gotcha ?? method.gotchas?.[0] ?? "",
  }
}

function validateMethod(method: AuthMethod) {
  const requiredChecks: Array<{ key: string; valid: boolean }> = [
    { key: "description", valid: typeof method.description === "string" },
    { key: "bestFor", valid: Array.isArray(method.bestFor) },
    { key: "avoidWhen", valid: Array.isArray(method.avoidWhen) },
    { key: "pros", valid: Array.isArray(method.pros) },
    { key: "cons", valid: Array.isArray(method.cons) },
    { key: "gotcha", valid: typeof method.gotcha === "string" },
    { key: "flows.happy", valid: Array.isArray(method.diagram?.flows?.happy) },
  ]

  const missing = requiredChecks.filter((check) => !check.valid).map((check) => check.key)
  if (missing.length > 0) {
    console.warn(`[AuthAtlas] Method "${method.id}" is missing required keys: ${missing.join(", ")}`)
  }
}

export const authMethods: AuthMethod[] = rawAuthMethods.map(normalizeMethod)

if (process.env.NODE_ENV !== "production") {
  authMethods.forEach(validateMethod)
}
